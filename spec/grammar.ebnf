(* NanoC grammar — informative reference
 * The parser is hand-written and is the authoritative source.
 * This document may lag behind the parser on fine details.
 *)

(* ─── Top-level ─────────────────────────────────────────────────────────── *)

program        = top_level_item* ;

top_level_item = struct_decl
               | var_decl
               | const_decl
               | constexpr_decl
               | function_decl
               | extern_decl
               ;

(* ─── Names ─────────────────────────────────────────────────────────────── *)

(* All three are syntactically IDENTIFIER; the distinction is semantic. *)
struct_name   = IDENTIFIER ;
variable_name = IDENTIFIER ;
label_name    = IDENTIFIER ;

(* ─── Types ─────────────────────────────────────────────────────────────── *)

type       = base_type "*"* ;
base_type  = primitive | struct_name ;
primitive  = "u8" | "i32" | "u32" | "ptr" ;

(* register-sized: permitted as function parameters and return values *)
reg_type   = primitive | base_type "*"+ ;

(* ─── Struct declarations ────────────────────────────────────────────────── *)

struct_decl  = "struct" struct_name "{" struct_field* "}" ;
struct_field = variable_name ":" type "," ;   (* trailing comma mandatory on every field *)

(* ─── Function declarations ─────────────────────────────────────────────── *)

function_decl = fn_modifier* "fn" variable_name
                "(" fn_params? ")"
                ("->" reg_type)?
                block ;

fn_modifier = "pub" | "inline" | "comptime" ;
fn_params   = fn_param ("," fn_param)* ;
fn_param    = variable_name ":" reg_type ;

(* ─── Extern declarations ────────────────────────────────────────────────── *)

(* Declares an external symbol without a body.
 * The optional string literal + "as" imports under a different local name,
 * used to avoid collisions with NanoC keywords (e.g. libc's syscall(2)).  *)
extern_decl = "extern" (STRING_LITERAL "as")? "fn" variable_name
              "(" fn_params? ")"
              ("->" reg_type)?
              ";" ;

(* ─── Variable declarations ─────────────────────────────────────────────── *)

(* var: mutable, stored, addressable *)
var_decl   = "var" variable_name ":" type "=" var_init ";" ;
var_init   = expression | "zeroed" | "undefined" ;

(* const: immutable, stored, addressable — runtime value, never folded.
 * "zeroed" and "undefined" are sema errors on const.                         *)
const_decl = "const" variable_name ":" type "=" expression ";" ;

(* constexpr: immutable, NOT stored, NOT addressable — compile-time only.
 * The initialiser must be a constexpr expression (sema-checked, not grammar). *)
constexpr_decl = "constexpr" variable_name ":" type "=" expression ";" ;

(* ─── Statements ─────────────────────────────────────────────────────────── *)

statement = var_decl
          | const_decl
          | constexpr_decl
          | lvalue "=" expression ";"        (* assignment is a statement, not an expression *)
          | call_expr ";"                    (* expression statement: calls and syscalls only *)
          | "return" expression? ";"
          | if_expr                          (* if is an expression; used as statement here — no trailing ";" *)
          | comptime_if                      (* compile-time conditional — condition must be constexpr *)
          | "while" "(" expression ")" block
          | "goto" label_name ";"
          | label_name ":" statement
          ;

(* ─── Blocks ─────────────────────────────────────────────────────────────── *)

(* A block is always an expression.
 * Its value is the final expression if present (no trailing ";"), else unit.
 *
 *   { stmt; stmt; expr }    -- type is typeof(expr)
 *   { stmt; stmt; expr; }   -- type is unit (the trailing ";" discards the value)
 *   { stmt; stmt; }         -- type is unit
 *   { }                     -- type is unit                                     *)
block = "{" statement* expression? "}" ;

(* ─── if expressions ─────────────────────────────────────────────────────── *)

(* if/else is always an expression.
 * Bodies MUST be blocks — bare expressions as bodies are a parse error.
 * "else if" is naturally "else" followed by a new if_expr: no special syntax.
 *
 * Type rules (enforced by sema):
 *   if without else            -- type is unit; error in value position
 *   if/else, branches agree    -- type is the shared branch type
 *   if/else, one branch never  -- type is the other branch's type            *)
if_expr = "if" "(" expression ")" block ("else" (if_expr | block))? ;

(* ─── comptime if ───────────────────────────────────────────────────────── *)

(* comptime if follows the same shape as if_expr but the condition must be a
 * constexpr expression (sema check, not grammar).
 * Dead branches are parsed and type-checked; only the live branch is emitted.
 * comptime does NOT apply to arbitrary expressions — only to if.             *)
comptime_if = "comptime" if_expr ;

(* ─── Lvalues ────────────────────────────────────────────────────────────── *)

(* Lvalue-ness is checked by sema, not enforced syntactically.
 * The parser accepts any expression on the LHS of "="; sema rejects non-lvalues.
 * Valid lvalues: variable_name, *expr, expr->field, expr[index].
 * Invalid lvalues: literals, arithmetic results, call results.               *)
lvalue = expression ;

(* ─── Expressions ────────────────────────────────────────────────────────── *)

(* All of the following are expressions and may appear wherever a value is needed. *)
expression = block
           | if_expr
           | pratt_expr
           ;

(* Pratt-parsed sub-expressions.
 * Precedence table, low to high:
 *   (1  assignment — floor only; assignment is a statement, this slot
 *                    is used when parsing the RHS to avoid over-consuming)
 *    2  ||
 *    3  &&
 *    4  |
 *    5  ^
 *    6  &
 *    7  == !=
 *    8  < <= > >=
 *    9  << >>
 *   10  + -
 *   11  * / %
 *   12  unary prefix:  ! ~ - (negate)  & (address-of)  * (deref)
 *   13  postfix:       -> .  []  ()                                          *)
pratt_expr = atom
           | pratt_expr bin_op pratt_expr
           | prefix_op pratt_expr
           | pratt_expr postfix
           ;

atom = INTEGER_LITERAL
     | STRING_LITERAL
     | "true"
     | "false"
     | variable_name
     | "(" expression ")"
     | call_expr
     | syscall_expr
     | "unreachable"           (* type: never — traps in debug builds, UB in release *)
     ;

(* DIVERGING EXPRESSIONS — type: never
 *
 * "unreachable" is the only diverging atom. Its never type unifies with any branch type:
 *
 *   const x: i32 = if (cond) { 42 } else { unreachable };  -- ✅
 *
 * "return" is a STATEMENT (see above), not an expression atom. However, the type checker
 * treats a block whose last statement is "return" as having type "never", producing the
 * same effect:
 *
 *   const x: i32 = if (cond) { 42 } else { return -1; };   -- ✅ block type is never
 *
 * "goto" is also a statement only and is additionally forbidden inside initializer
 * expressions. Unlike return/unreachable, goto jumps to a label within the same function,
 * and the label target may be in a scope where the partially-initialized binding is
 * visible. This is the classic "goto past declaration" hazard, but from the inside.     *)

call_expr   = expression "(" (expression ("," expression)*)? ")" ;
syscall_expr = "syscall" "(" expression ("," expression)* ")" ;

bin_op = "||" | "&&"
       | "|" | "^" | "&"
       | "==" | "!=" | "<" | "<=" | ">" | ">="
       | "<<" | ">>"
       | "+" | "-"
       | "*" | "/" | "%"
       ;

prefix_op = "!" | "~" | "-" | "&" | "*" ;

(* Note: expr[expr] — left operand must be pointer/array (sema check).
 * i[arr] is rejected by sema even though the grammar accepts it.            *)
postfix = "->" variable_name
        | "." variable_name
        | "[" expression "]"
        | "(" (expression ("," expression)*)? ")"
        ;
